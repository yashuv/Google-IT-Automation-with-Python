## Advanced Git interaction:
---------------------------
git commit -a
- shortcut to stage any changes to tracked files and commit them in one step.
- commit all changes to files that are already tracked by Git. This means that any changes to files that are not tracked by Git will not be included in the commit. for eg: Git commit -a doesn't work on new files because those are untracked.

git commit -a -m "message"
- (git commit -a) + add commit message directly.

git log -p
- display the full commit history of a repository, including the diffs of each commit. This is useful for seeing the complete history of a repository, as well as understanding the changes that have been made to the code over time.
- format is equivalent to (diff -u) output.
- The p comes from patch, because using this flag gives us the patch that was created.

git show commitID
- show git commit log of particular commitID, and its diff.

git log --stat
- display a log of commits with accompanying file statistics.

git add -p
- show us(review) the change (patch) being added and ask us if we want to stage it or not.

git diff
- shows only unstaged changes by default.

git diff --staged
- shows changes that are staged but not committed.

## Deleting and Renaming Files:
----------------------------
ls -l
- first see the content of directory

git rm file_name
- delete the file

ls -l
- check the content again(if the file is deleted).

git status
- finally, check the status

Until here, the change is also staged to be committed in the next commit.

git commit -m "delete message"
- commit with delete message

Now, renaming:

git mv old_filename new_filename
- rename the filename

git status
- shows us that the file was renamed and clearly displays the old and new names.
- As with previous example(delete), the change is staged but not committed.

git commit -m "rename message"
- commit with renamed msg

---

.gitignore file
-inside this file we specifie the set of rules to tell git which files to ignore(skip) when tracking changes in a repository. The command takes a single argument, which is the path to a file containing a list of patterns to ignore.

For example, if we're working on an OSX computer, we'll probably want to ignore the dot DS store file, which is automatically generated by the operating system.

echo .DS_STORE > .gitignore
- create a .gitignore file containing the name of file to ignore.

Note: The dot prefix indicates that the directory is hidden.

ls -la
- list all files(including hidden).
- check whether the above gitignore file is created.

We've added a gitignore file to our repo but we haven't committed it yet. So to track changes:
git add .gitignore
- add to staging area

git commit -m "add a gitignore file, ignoring .DS_STORE files"
- commit changes to gitignore with msg


## Undoing changes before commit:
--------------------------------
The ability to undo our changes is one of the most powerful features offered by version control systems. There are a bunch of different techniques available depending on which changes we need to undo. We'll learn about the most common ways to undo changes in Git and when to use each approach.<br>
By deleting the function from original script, we've actually broke the script. Using *git status*, as expected, we see that our file is modified and the changes aren't staged yet. Check out how git gives us a couple helpful tips on what to do now. We can run *git add* to stage our changes or we can run *git checkout* to discard them.

git checkout filename
- restore a file to its previous version(revert changes to modified files before they are staged). i.e: restore file to the latest snapshot

git status
- see status as previously committed state

git checkout -p filename
- selectively apply changes from a given commit.
- checkout individual changes instead of whole file.

That's it for undoing unstaged changes. <br>

 What if you added the changes to the staging area already?<br>
 Don't stress. If we realize we've added something to the staging area that we didn't actually want to commit, we can unstage our changes by using the *git reset* command.
 
 git reset HEAD file
 - unstage a file that was staged.
 - HEAD alias means the current checked out snapshot.
The file is once again untracked in the working tree and no longer staged.<br>
You can think of reset as the counterpart to add. With add, you can add changes to the staging area. With reset, you remove changes from the staging area

git reset -p 
- select specific changes you want to reset

But what if you've already created a commit with the changes that you want to undo?

## Amending Commits:
-------------------
git commit --amend
- modify the most recent commit.
- git will take whatever is currently in our staging area and run the git commit workflow to overwrite the previous commit.
for eg:
touch auto-update.py
- create file

touch gather-information.sh 
- create file

ls -l
- list directory to see file creation

git add auto-update.py
- add a file to staging area

git commit -m "Add two new scripts"
- commit saying two files added

Here, the msg printed by git says that only one file was added. Our commit msg said that we added two files, but we forget to add one of them. We can fix this!

we now add the missing file and amend our commit:

git add gather-information.sh
- add the missing file to staging area

git commit --amend
- This will open up the editor with your last commit message. You can edit the message and save it to amend your last commit.

Hence, we ammended our previous commit to include both files and a better message.
We've covered how to fix staged and unstaged changes, and how to fix a commit that was incomplete.

Up next, we'll talk about what to do if you come across a bad commit that needs to be completely reverted.


## Rollbacks:
------------
Fixing your work before you commit is good. But what happens if it's already been snapshotted by Git? Let's say you host to Git repository on a company server that contains all kinds of useful automation scripts that you and your coworkers use. One morning before coffee, you make a few changes to one of these scripts and commit the updated files. A few hours later, you start to receive tickets from users indicating some part of the script is broken. From the errors they describe, it sounds like the problem is related to your recent changes. Oh, you could look at the code you updated to see if you can spot the bug. But more tickets are pouring in and you want to fix the problem as fast as possible. You decided it's time for a *rollback*. 
There are a few ways to rollback commits in Git. For now, we'll focus on using the git revert command. Git revert doesn't just mean undo. Instead, it creates a commit that contains the inverse of all the changes made in the bad commit in order to cancel them out.
For example, if a particular line was added in the bad commit, then in the reverted commit, the same line will be deleted. This way you get the effect of having undone the changes, but the history of the commits in the project remains consistent leaving a record of exactly what happened. So git revert will create a new commit, that is the opposite of everything in the given commit.We can revert the latest commit by using the head alias that we mentioned before.
Since we can think of head as a pointer to the snapshot of your current commit, when we pass head to the revert command we tell Git to rewind that current commit.
To check this out, we will add a faulty commit to our repo,lets say:
- cwd
- open file and modify scripts in file named abc.py
- git commit -a -m "Add call to disk full function"

  So now, our code is committed. We didn't even test it which is a bad idea if you're doing this for real. You might have already spotted the problem with our code. This is where users start filing tickets and saying that things are broken, and so we run our script to see what happens.
  
- ./abc.py
	 say, we use the function that we forgot to define.

okay it's rollback time.

Let's get rid of this faulty code by typing:
	git revert HEAD

So, once we issue that git revert command, we're presented with the text editor commit interface. In this case, we can see that git has automatically added some text to the command indicating it's a rollback.
The first-line mentions that it's reverting the commit we just did called "Add call to disk full function". The extra description even includes the identifier of the commit that got reverted. While we could use this description as is, it's usually a good idea to add an explanation of why we're doing the rollback. Remember that the goal of these descriptions is to help our future selves understand why things happen. In this case, we'll explain that the reason for the rollback is that the code was calling a function that wasn't defined.

(Add the reason to the editor)
Reason for rollback: the disk_full function is undefined.

Once done entering description, exit and save as usual.

You'll notice the output that we get from the git revert command looks like the output of the *git commit* command. This is because git revert creates a commit for us. Since a revert is a normal commit, we can see both the commit and the reverted commit in the log. Let's look at the last two entries in the log using:

     log -p -2 

As demonstrated before, the -p parameter lets us see the patch created by the commit while the -2 parameter limits the output to the last two entries.
So in this log, we can see that when we called revert, git created a new commit that's the inverse of the previous one. This removes the lines that we added in the previous commit.

We can see that the original commit shows the lines we added by preceding them with a plus sign. The same line shows up with a minus sign in the newer commit message indicating that they were removed. Just like that, the bad commit is reverted and the error stopped.<br>
In this example, we reverted the latest commit in our tree.

But what if we had to revert a commit that was done before that? We see next.

## Identifying a commit
 we've used the head alias to specify the most recently checked out commit in our Git history. In our bad snapshot example, the error also happened to be in the most recently created commit, but errors can sometimes take a while to be detected. And so, we might need to revert other commits farther back in time. We can target a specific commit by using its commit ID. We've seen commit IDs a few times already. They show up when we're running the git log command, and we also saw the commit ID of the reverted commit in our last example. Commit IDs are those complicated looking strings that appear after the word commit in the log messages. <br>
We can use commit IDs to specify a particular commit to work with, like during a rollback.Let's look at the last two entries in our repo using the command:
		git log -2 (here we can find the "commitID")
			
Say we realized that we actually liked the previous name of our script(instead of renaming), and so we want to revert this commit where we renamed it. First, let's look at that specific commit using:
		git show "commitID" (copy and paste the commitID from above that we want to display)
	- shows that we have renamed scripts from old.py to new.py

And that works!

Since we can identify the commit that we want to revert, let's call the revert command with this identifier:

	     git revert commitID

As usual, this will open an editor where we should add a reason for the rollback. In this case, we'll say that the previous name was actually better.
			
	(Add the reason to the editor)
Reason for rollback: previous name was actually better.
      
As we already know that when we generate the rollback, Git automatically includes the ID of the commit that we're reverting. This is useful when looking at a repo with a complicated history that includes a lot of commits. Now, once we save and exit the commit message, Git will actually perform the rollback and generate a new commit with its own ID. i.e: before the name of our commit the revert command already shows the first eight characters of the commit ID.<br>
Let's use git show to look at it:
			git show 'new commitID'
			- see the effect of rollback that took place
			
Thus, we've managed to revert a commit that wasn't the most recent one.



## Branching and Merging
------------------------

## What is a branch?
In Git, a branch at the most basic level is just a pointer to a particular commit. But more importantly, it represents an independent line of development in a project. The commit it points to is the latest link in a chain of developing history. 
The default branch that Git creates for you when a new repository initialized is now **main**. Previously, it was master. The default branch is commonly used to represent the known good state of a project. <br>
When you want to develop a feature or try something new in your project, you can create a separate branch to do your work without worrying about messing up this current working state. 

### Why branches?
Branches make it really easy to experiment with new ideas or strategies and projects. When you want to add a feature or fix something, you can create a new branch and do your development there. You can merge back into the main branch, when you've got something you like, or discard your changes without negative impact if they don't work out. In Git, branches are used all the time, as a part of the normal development workflow.

We'll look into how to create new branches and merge their content into the default branch.

### Creating New Branches
As branches are essential to how work is done in git, there's tons of different ways to work with them. We can use the *git branch* command to *list, create, delete, and manipulate* branches. Running git branch by itself will show you a list of all the branches in your repository. <br>
Let's try it out in our repo.

* git branch
\- shows the list of branch

* git branch new-feature  
\- create a new branch

We are currently be in default branch, but right now we want to switch to a new branch called new-feature (naming is your choice). To do that, we'll need to use the *git checkout* command. We saw earlier how we can use git checkout to restore a modified file back to the latest commit.<br>
Checking out branches is similar in that, the working tree is updated to match the selected branch including both the files and the git history.<br>

* It might help to remember that we use git checkout to check out the latest snapshot for both files and for branches. 

Let's switch to our newBranch branch by calling: 

* git checkout new-feature
\- switch to our newly created branch

* git branch
\- listing our branches once again.

Before we were working on the default branch but now that we've changed to our new branch, the star(asterisk) has moved to new branch. 

Git gives us a useful shortcut to *create a new branch and to switch to it in a single command*.

* git checkout -b even-better-feature
\- create the new branch and switch to it in just one command. Super efficient.

Now that we have our shiny new branch, let's create a new file in it. We'll create a new Python3 file, that will include the usual shebang line and empty main function and a call to that function.
	* atom hello.py
	- create new file
	
<pre>
# In hello.py file

def main():
	pass
	
main()
</pre>
	
This file is empty(incomplete) because it's only the beginning of our work. As it's in a separate branch, it's okay for it to not be finished yet. <br>
Let's save our file and commit it to the current branch(even-better-feature) now.

* git add hello.py
\- add to staging area

* git commit "Add an empty hello.py"
\- commit it with msg

Alright, we've added a commit in this branch. Let's check the last two entries in the log.
	* git log -2
	- see the last two commit in the branch
	
(In the output of above log command)	
Notice how next to the latest commit ID, git shows that this is where head is pointing to and that the branch is called even better feature. Next to the previous commit, git shows that both the master and the new feature branches are pointing to that snapshot of the project. <br>
In this way, we can see that the *even better feature* branch is ahead of the *master* branch.

With that, we've seen how we can create new branches and commit changes to them.
Next, we'll learn even more things we can do to operate with branches. So stick around.

### Working with Branches
Previously, we created a new branch different than the master branch and added a commit to it. Let's check out the current status of our repo by calling:
* git status
\- current status of our repo
\- we see that we're on a clean working tree in the *even-better-feature* branch

<br>

* ls -l
\- list files in our current working directory
\- we that a new *hello.py* file is in our working tree

Let's now change back to the master branch and then lists the latest two commits there.
* git checkout master
\- change back to master branch

<br>

* git log -2
\- lists the latest two commits there.
	
When we switch to a different branch using git checkout, git changes where head is pointing.
 
In doing so, head goes from pointing to the latest commit in the *even better feature* branch to the most recent commit of the *master* branch. The commit from even better feature doesn't show up at all.

Remember that when we switch branches, git will also change files in our working directory or working tree to whatever snapshot head is currently pointing at. <br>
Let's look at the current contents of our directory.

* ls -l
\- list curent content of directory
\- (we can see that hello.py isn't there)

This demonstrates that when we switch branches in git, the working directory and commit history will be changed to reflect the snapshot of our project in that branch. When we check out a new branch and commit on it, those changes will be added to the history of that branch. Since *hello.py* was committed on another branch, it doesn't show up in the history or working directory of the master branch.
	
One thing to note after all this back and forth, is that *each branch is just a pointer to a specific commit in a series of snapshots*.
We've now seen how to create and switch between branches. We can also delete a branch that we don't need anymore.

* git branch
\- list the branch

* git branch -d new-feature
\- delete appropriate branch 
	
* git branch
- list branch where new-feature is not there anymore.
	
If there are *changes in the branch we want to delete that haven't been merged back into the master branch*, git will let us know with an *error*.

	* git branch -d even-better-feature
	- shows error because we haven't merged changes
	
	* git branch -D even-better-feature
	- delete branch even it has unmerged changes
	
We actually want to *merge* those changes back into the repo first.
	
## Merging
A typical workflow for managing branches in Git, is to create a separate branch for developing any new features or changes. Once the new feature's in good shape, we merge the separate branch back into the main trunk of code.
* Merging is the term that Git uses for combining branch data and history together.

We'll use the *git merge* command, which lets us take the independent snapshots and history of one Git branch, and tangle them into another.
Let's try this out with our example branch from previous section. First, will check that we're in master branch.

*  git branch
\- see we are in master branch with star in front
	
Then, we'll call:
* git merge even-better-feature
\- to merge the even-better-feature branch into the master branch.
	
We can see the log of changes using:
* git log
\- see log of changes doing merge.
	
As we're on the master branch, *HEAD* points at *master*. We can see the *even-better-feature and master branches are now both pointing at the same commit*.

Git uses two different algorithms to perform a merge, *fast-forward* and *three-way* merge. The merge we just performed is an example of a *fast-forward merge*. This kind of merge occurs when all the commits in the checked out branch are also in the branch that's being merged. If this is the case, we can say that the commit history of both branches doesn't diverge. In these cases, all Git has to do is update the pointers of the branches to the same commit, and no actual merging needs to take place. 
On the other hand, a *three-way merge* is performed when the history of the merging branches has diverged in some way, and there isn't a nice linear path to combine them via fast-forwarding. This happens when a commit is made on one branch after the point when both branches split. In our case, this could have happened if we made a commit on the master branch after creating the other branches.

<!-- When this occurs, Git will tie the branch histories together with a new commit. And merge the snapshots at the two branch tips with the most recent common ancestor, the commit before the divergence. To do this successfully, Git tries to figure out how to combine both snapshots. If the changes were made in different files, or in different parts of the same file, Git will take both changes and put them together in the result. If instead the changes are made on the same part of the same file, Git won't know how to merge those changes, and the attempt will result in a merge conflict. This sounds scary, but don't panic. Git doesn't quit, we'll solve those conflicts in our next video.-->

**Merge Conflict**
We might find that both the branches we're trying to merge have edits to the same part of the same file. This will result in something called a merge conflict.<br>
Normally, Git can automatically merge files for us. But when we have a *merge conflict*, it will need a little help to figure out what to do. To see how this would look, let's edit the *hello.py* file in the master branch and replace the pass statement with a comment about what the main function should do.

* atom hello.py
\- open file
	
<pre>
# In hello.py file

def main():
"""Greets the user """
	
main()
</pre>

We made the change so let's save it and commit it back to our *master branch*.

* git commit -a -m 'Add comment to main()'
\- commmit changes to branch
	
Next, Let's check out the *even-better-feature* branch and make a change in the same place.

* git checkout even-better-feature
\- switch to even-better-feature branch
	
* atom hello.py
\- open file and make changes
	
In this case, we will replace the call to pass with a call to print, saying that "Hello World, User!".

<pre>
# In hello.py file

def main():
	print("Hello World, User!")
	
main()
</pre>

Now, we'll save this other change and commit it to this branch.

* git commit -a -m "Print Hello World, User!"
	
We are primed for chaos with our file all setup for a merge conflict. Let's check out the master branch again and try to merge the even-better-feature back into it.
	
* git checkout master 
\- switch to master branch

* git merge even-better-feature
\- try merging this branch
\- (Git tells us it tried to automatically merge the two versions of the hello.py file, but it didn't know how to do it.)

We can get more information about what's going on using the command:
* git status
	
As usual, *git status* gives us a lot of additional information. It tells us that we have files that are currently unmerged, and that we need to fix the conflicts or abort the merge if we decide it was a mistake. It also tells us that we need to run Git add on each unmerged file to mark that the conflicts have been resolved.Fine!

To fix the conflict, let's open up hello.py in our text editor.
* atom hello.py
	
<!-- Thankfully, Git has added some information to our files to tell us which parts of the code are conflicting. The unmerged content of the file at head, remember, in this case, head points to master, is the docstring stating what the main function should do. The unmerged content of the file in the even-better-feature branch is the call to the print function. It's up to us to decide which one to keep or if we should change the contents of the file altogether. In this case, we'll keep both statements and delete the merger markers. -->
Git has adds some information to our files to tell us which parts of the code are conflicting. We'll keep both statements and delete the merger markers.

<pre>
# In hello.py file

def main():
"""Greets the user """
	print("Hello World, User!")
	
main()
</pre>
	
Now that we've fixed the conflict, we'll mark it as resolved by running:

* git add hello.py
\- stage the file changes 
	
And then see how our merge is doing by calling:
* git status
\- git now tells us that all conflicts have been resolved
	
We just need to conclude the merge by committing changes.

* git commit
\- opens the editor to add description
\- lets add description msg as "kept lines from both branches"
	
The comments that git commit shows us look different than other commits. That's because this is a merge and Git tells us so. It also tells us which file had conflicts which have now been resolved. The commit already has a description saying that it's merging the other branch. This description was automatically created when we called the git merge command. But we can add onto this description if we want. For example, we can say that we're keeping the lines from both branches, and then just save and exit as usual.<br>
The merge conflict is resolved. 

To see what the commit history looks like now, we'll use a couple of handy options to the *git log* command.

* git log --graph --oneline
\- graph for seeing the commits as a graph, and oneline to only see one line per commit
	
<br>

This format helps us better understand the history of our commits and how merges have occurred.

<!-- We can see the new commit that was added and also the two separate commits that we merged. One coming from the master branch and the other coming from the even-better-feature branch. We can also see that master is pointing to the merge commit but even-better-feature is still pointing to the previous one -->

In our example, resolving the conflict was straightforward and easy. But in the real world, this won't always be the case. Merge conflicts can sometimes be tricky, complicated, and spread across multiple files. If you want to throw the merge away and start over, an escape hatch, you can use the command:

* git merge --abort 
\-  stop the merge and reset the files in your working tree back to the previous commit before the merge ever happened.


### Conclusion
I have an advanced understanding of Git and can skip the staging area to delete and move files within Git. I can also amend and roll back commits.

I understand the concept of branching and merging by knowing how to create, delete, and switch between branches in Git. I've also seen that each branch represents a pointer to a commit in a sequence of independent snapshots. I know how to merge these commits back into the main trunk by using the git merge command. I can also manage and handle merge conflicts.

<!-- We've learned a lot more about how to interact with Git. We started with some advanced commands, like skipping the staging area, getting additional info about our commits, and being able to delete and rename files in our repository.

After that, we dove into one of the main concepts of version control, the ability to undo things. We looked at how to revert unstaged and staged changes, how to amend commits, and how to perform rollbacks, whether from the latest commit or an older one. Finally, we cut through the entangled world of branching. We learned how to create, switch to, and delete branches. We looked into how to merge branches, and how to solve pesky merge conflicts when they cause trouble. There's an assessment coming up to help you put all of your new skills into action. -->